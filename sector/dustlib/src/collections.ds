/// Collections forge.
///
/// The `collections` forge defines basic data structures used throughout
/// dustlib.  These include an `Array<T>` shape representing a
/// growable array of values backed by a memory region and a
/// `List<T>` shape representing a singly linked list.  Processes to
/// create and manipulate these structures are declared but not yet
/// implemented.

forge collections {
    /// A growable array of values of type `T`.  The `length` field
    /// stores the number of elements, while `data` holds a `Mem`
    /// handle pointing to the allocated memory.  `Mem` is a resource
    /// type defined by the K‑regime semantics【709885362819930†L42-L64】.
    shape Array<T> = {
        length: Int;
        data: Mem;
    };

    /// A node in a singly linked list.  Each node holds a value of
    /// type `T` and an optional pointer to the next node.  The type
    /// `Node<T>?` denotes an optional node.
    shape Node<T> = {
        value: T;
        next: Node<T>?;
    };

    /// A singly linked list.  The `head` field points to the first
    /// node in the list or is `null` if the list is empty.
    shape List<T> = {
        head: Node<T>?;
    };

    /// Create a new array with the given length.  This process will
    /// allocate `length` elements of type `T` and return an `Array<T>`.
    /// Memory allocation is a K‑regime effect; the implementation will
    /// call `alloc` internally.  For now, the body is left empty.
    process new<T>(length: Int) -> Array<T> = {
        // TODO: allocate memory and return a new array
    };

    /// Return the length of the array.
    process length<T>(arr: Array<T>) -> Int = {
        return arr.length;
    };

    /// Push a value onto the array.  This process increases the
    /// length by one and writes the value into the allocated region.
    /// It is declared but not implemented.
    process push<T>(arr: Array<T>, value: T) -> Array<T> = {
        // TODO: reallocate memory if necessary and append value
    };

    /// Pop a value from the array.  Returns a tuple containing the
    /// popped value and the updated array.  The result type is
    /// represented as `(T, Array<T>)` in DPL notation.
    process pop<T>(arr: Array<T>) -> (T, Array<T>) = {
        // TODO: remove last element and shrink array
    };

    /// Create an empty list.
    process empty<T>() -> List<T> = {
        let lst: List<T> = { head: null };
        return lst;
    };

    /// Push a value onto the front of the list.  Returns the new
    /// list with the value prepended.
    process push_front<T>(lst: List<T>, value: T) -> List<T> = {
        // TODO: allocate a new node and update head
    };

    /// Pop a value from the front of the list.  Returns a tuple
    /// containing the popped value (or `null` if empty) and the
    /// updated list.
    process pop_front<T>(lst: List<T>) -> (T?, List<T>) = {
        // TODO: remove head node and return value
    };
}