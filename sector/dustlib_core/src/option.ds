// option.ds: Definition and implementation of the Option<T> type.

use sector::{Debug, FormatError, Formatter};

// `Option<T>` is a type that represents a value that may or may not be present.
// It is an enum with two variants: `Some(T)` if the value is present, and `None` if it is absent.
pub enum Option<T> {
    Some(T),
    None,
}

impl<T> Option<T> {
    // Returns true if the option is a `Some` value.
    pub fn is_some(&self) -> bool {
        match self {
            Some(_) => true,
            None => false,
        }
    }

    // Returns true if the option is a `None` value.
    pub fn is_none(&self) -> bool {
        !self.is_some()
    }

    // Unwraps the option, yielding the content of a `Some`.
    // Panics if the value is a `None`.
    pub fn unwrap(self) -> T
    where
        T: Debug, // Requires the inner type to implement Debug for panic message
    {
        match self {
            Some(val) => val,
            None => panic!("Called `option.unwrap()` on a `None` value"),
        }
    }

     // Returns the contained value or a default.
    pub fn unwrap_or(self, default: T) -> T {
        match self {
            Some(val) => val,
            None => default,
        }
    }

    // Returns the contained value or computes it from a closure.
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T,
    {
        match self {
            Some(val) => val,
            None => f(),
        }
    }

    // Maps an Option<T> to Option<U> by applying a function to a contained Some value,
    // leaving a None value untouched.
    pub fn map<U, F>(self, f: F) -> Option<U>
    where
        F: FnOnce(T) -> U,
    {
        match self {
            Some(x) => Some(f(x)),
            None => None,
        }
    }

    // Returns `None` if the option is `None`, otherwise calls `predicate` with the
    // wrapped value and returns:
    // - `Some(t)` if `predicate` returns `true`
    // - `None` if `predicate` returns `false`
    pub fn filter<P>(self, predicate: P) -> Option<T>
    where
        P: FnOnce(&T) -> bool,
    {
        match self {
            Some(x) => {
                if predicate(&x) { Some(x) } else { None }
            },
            None => None,
        }
    }

    // Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to
    // `Ok(v)` and `None` to `Err(err)`.
    pub fn ok_or<E>(self, err: E) -> Result<T, E> {
        match self {
            Some(v) => Ok(v),
            None => Err(err),
        }
    }

    // Returns the contained value, consuming the `self` value.
    // Panics if the value is `None` with a custom panic message provided by `msg`.
    pub fn expect(self, msg: &str) -> T {
        match self {
            Some(val) => val,
            None => panic!("{}", msg),
        }
    }
}

// Optionally, implement Display for Option if useful.
// This requires T to implement Display.
impl<T> Display for Option<T>
where
    T: Display,
{
    fn fmt(self, f: &mut Formatter) -> Result<(), FormatError> {
        match self {
            Some(v) => {
                f.write_str("Some(")?;
                v.fmt(f)?;
                f.write_str(")")
            }
            None => f.write_str("None"),
        }
    }
}